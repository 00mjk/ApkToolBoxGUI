<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BigFileReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">APKToolBoxGUI</a> &gt; <a href="index.source.html" class="el_package">edu.jiangxin.apktoolbox.file.password.recovery.dictionary</a> &gt; <span class="el_source">BigFileReader.java</span></div><h1>BigFileReader.java</h1><pre class="source lang-java linenums">package edu.jiangxin.apktoolbox.file.password.recovery.dictionary;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.*;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicLong;

public class BigFileReader {
<span class="nc" id="L17">    private static Logger logger = LogManager.getLogger(BigFileReader.class);</span>

    private int threadSize;
    private String charset;
    private int bufferSize;
    private FileHandle handle;
    private ScheduledThreadPoolExecutor executorService;
    private long fileLength;
    private RandomAccessFile rAccessFile;
    private Set&lt;StartEndPair&gt; startEndPairs;
    private CyclicBarrier cyclicBarrier;
<span class="nc" id="L28">    private AtomicLong counter = new AtomicLong(0);</span>
    private CompleteCallback completeCallback;

<span class="nc" id="L31">    private BigFileReader(File file, FileHandle handle, String charset, int bufferSize, int threadSize) {</span>
<span class="nc" id="L32">        this.fileLength = file.length();</span>
<span class="nc" id="L33">        this.handle = handle;</span>
<span class="nc" id="L34">        this.charset = charset;</span>
<span class="nc" id="L35">        this.bufferSize = bufferSize;</span>
<span class="nc" id="L36">        this.threadSize = threadSize;</span>
        try {
<span class="nc" id="L38">            this.rAccessFile = new RandomAccessFile(file, &quot;r&quot;);</span>
<span class="nc" id="L39">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L40">            logger.error(&quot;BigFileReader FileNotFoundException&quot;);</span>
<span class="nc" id="L41">        }</span>
<span class="nc" id="L42">        this.executorService = new ScheduledThreadPoolExecutor(threadSize);</span>
<span class="nc" id="L43">        startEndPairs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L44">    }</span>

    public void setCompleteCallback(CompleteCallback completeCallback) {
<span class="nc" id="L47">        this.completeCallback = completeCallback;</span>
<span class="nc" id="L48">    }</span>

    public void start() {
<span class="nc" id="L51">        long everySize = fileLength / threadSize;</span>
        try {
<span class="nc" id="L53">            calculateStartEnd(0, everySize);</span>
<span class="nc" id="L54">        } catch (IOException e) {</span>
<span class="nc" id="L55">            logger.error(&quot;start&quot;, e);</span>
<span class="nc" id="L56">            return;</span>
<span class="nc" id="L57">        }</span>

<span class="nc" id="L59">        final long startTime = System.currentTimeMillis();</span>
<span class="nc" id="L60">        cyclicBarrier = new CyclicBarrier(startEndPairs.size(), () -&gt; {</span>
<span class="nc" id="L61">            logger.info(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span>
<span class="nc" id="L62">            logger.info(&quot;all line: &quot; + counter.get());</span>
<span class="nc" id="L63">            completeCallback.onComplete();</span>
<span class="nc" id="L64">        });</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        for (StartEndPair pair : startEndPairs) {</span>
<span class="nc" id="L66">            logger.info(&quot;pair: &quot; + pair);</span>
<span class="nc" id="L67">            executorService.execute(new SliceReaderTask(pair));</span>
<span class="nc" id="L68">        }</span>
<span class="nc" id="L69">        handle.init();</span>
<span class="nc" id="L70">    }</span>

    private void calculateStartEnd(long start, long size) throws IOException {
<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (start &gt; fileLength - 1) {</span>
<span class="nc" id="L74">            return;</span>
        }
<span class="nc" id="L76">        StartEndPair pair = new StartEndPair();</span>
<span class="nc" id="L77">        pair.start = start;</span>
<span class="nc" id="L78">        long endPosition = start + size - 1;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if (endPosition &gt;= fileLength - 1) {</span>
<span class="nc" id="L80">            pair.end = fileLength - 1;</span>
<span class="nc" id="L81">            startEndPairs.add(pair);</span>
<span class="nc" id="L82">            return;</span>
        }

<span class="nc" id="L85">        rAccessFile.seek(endPosition);</span>
<span class="nc" id="L86">        byte tmp = (byte) rAccessFile.read();</span>
<span class="nc bnc" id="L87" title="All 4 branches missed.">        while (tmp != '\n' &amp;&amp; tmp != '\r') {</span>
<span class="nc" id="L88">            endPosition++;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (endPosition &gt;= fileLength - 1) {</span>
<span class="nc" id="L90">                endPosition = fileLength - 1;</span>
<span class="nc" id="L91">                break;</span>
            }
<span class="nc" id="L93">            rAccessFile.seek(endPosition);</span>
<span class="nc" id="L94">            tmp = (byte) rAccessFile.read();</span>
        }
<span class="nc" id="L96">        pair.end = endPosition;</span>
<span class="nc" id="L97">        startEndPairs.add(pair);</span>

<span class="nc" id="L99">        calculateStartEnd(endPosition + 1, size);</span>
<span class="nc" id="L100">    }</span>


    public void shutdown(boolean now) {
        try {
<span class="nc" id="L105">            rAccessFile.close();</span>
<span class="nc" id="L106">        } catch (IOException e) {</span>
<span class="nc" id="L107">            logger.error(&quot;shutdown IOException&quot;);</span>
<span class="nc" id="L108">        }</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (now) {</span>
<span class="nc" id="L110">            executorService.shutdownNow();</span>
        } else {
<span class="nc" id="L112">            executorService.shutdown();</span>
        }
<span class="nc" id="L114">        logger.info(&quot;shutdown executorService&quot;);</span>
<span class="nc" id="L115">    }</span>

    public void shutdown() {
<span class="nc" id="L118">        shutdown(false);</span>
<span class="nc" id="L119">    }</span>

    private void handle(byte[] bytes) throws UnsupportedEncodingException {
        String line;
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (charset == null) {</span>
<span class="nc" id="L124">            line = new String(bytes);</span>
        } else {
<span class="nc" id="L126">            line = new String(bytes, charset);</span>
        }
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (StringUtils.isNotEmpty(line)) {</span>
<span class="nc" id="L129">            handle.handle(line, counter.incrementAndGet(), this);</span>
        }
<span class="nc" id="L131">    }</span>

    private static class StartEndPair {
        public long start;
        public long end;

        @Override
        public String toString() {
<span class="nc" id="L139">            return &quot;star=&quot; + start + &quot;;end=&quot; + end;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L144">            final int prime = 31;</span>
<span class="nc" id="L145">            int result = 1;</span>
<span class="nc" id="L146">            result = prime * result + (int) (end ^ (end &gt;&gt;&gt; 32));</span>
<span class="nc" id="L147">            result = prime * result + (int) (start ^ (start &gt;&gt;&gt; 32));</span>
<span class="nc" id="L148">            return result;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (this == obj)</span>
<span class="nc" id="L154">                return true;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L156">                return false;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (getClass() != obj.getClass())</span>
<span class="nc" id="L158">                return false;</span>
<span class="nc" id="L159">            StartEndPair other = (StartEndPair) obj;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            if (end != other.end)</span>
<span class="nc" id="L161">                return false;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (start != other.start)</span>
<span class="nc" id="L163">                return false;</span>
<span class="nc" id="L164">            return true;</span>
        }

    }

    private class SliceReaderTask implements Runnable {
        private long start;
        private long sliceSize;
        private byte[] readBuff;

<span class="nc" id="L174">        public SliceReaderTask(StartEndPair pair) {</span>
<span class="nc" id="L175">            this.start = pair.start;</span>
<span class="nc" id="L176">            this.sliceSize = pair.end - pair.start + 1;</span>
<span class="nc" id="L177">            this.readBuff = new byte[bufferSize];</span>
<span class="nc" id="L178">        }</span>

        @Override
        public void run() {
            try {
<span class="nc" id="L183">                MappedByteBuffer mapBuffer = rAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, start, this.sliceSize);</span>
<span class="nc" id="L184">                ByteArrayOutputStream bos = new ByteArrayOutputStream();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                for (int offset = 0; offset &lt; sliceSize; offset += bufferSize) {</span>
                    int readLength;
<span class="nc bnc" id="L187" title="All 2 branches missed.">                    if (offset + bufferSize &lt;= sliceSize) {</span>
<span class="nc" id="L188">                        readLength = bufferSize;</span>
                    } else {
<span class="nc" id="L190">                        readLength = (int) (sliceSize - offset);</span>
                    }
<span class="nc" id="L192">                    mapBuffer.get(readBuff, 0, readLength);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    for (int i = 0; i &lt; readLength; i++) {</span>
<span class="nc" id="L194">                        byte tmp = readBuff[i];</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">                        if (tmp == '\n' || tmp == '\r') {</span>
<span class="nc" id="L196">                            handle(bos.toByteArray());</span>
<span class="nc" id="L197">                            bos.reset();</span>
                        } else {
<span class="nc" id="L199">                            bos.write(tmp);</span>
                        }
                    }
                }
<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (bos.size() &gt; 0) {</span>
<span class="nc" id="L204">                    handle(bos.toByteArray());</span>
                }
<span class="nc" id="L206">                cyclicBarrier.await();//测试性能用</span>
<span class="nc" id="L207">            } catch (InterruptedException e) {</span>
<span class="nc" id="L208">                logger.error(&quot;run InterruptedException&quot;);</span>
<span class="nc" id="L209">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L210">            } catch (Exception e) {</span>
<span class="nc" id="L211">                logger.error(&quot;run Exception&quot; + e.getMessage());</span>
<span class="nc" id="L212">            }</span>
<span class="nc" id="L213">        }</span>

    }

    public static class Builder {
<span class="nc" id="L218">        private int threadSize = 1;</span>
<span class="nc" id="L219">        private String charset = null;</span>
<span class="nc" id="L220">        private int bufferSize = 1024 * 1024;</span>
        private FileHandle handle;
        private File file;

<span class="nc" id="L224">        public Builder(String file, FileHandle handle) {</span>
<span class="nc" id="L225">            this.file = new File(file);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (!this.file.exists())</span>
<span class="nc" id="L227">                throw new IllegalArgumentException(&quot;文件不存在！&quot;);</span>
<span class="nc" id="L228">            this.handle = handle;</span>
<span class="nc" id="L229">        }</span>

        public Builder withThreadSize(int size) {
<span class="nc" id="L232">            this.threadSize = size;</span>
<span class="nc" id="L233">            return this;</span>
        }

        public Builder withCharset(String charset) {
<span class="nc" id="L237">            this.charset = charset;</span>
<span class="nc" id="L238">            return this;</span>
        }

        public Builder withBufferSize(int bufferSize) {
<span class="nc" id="L242">            this.bufferSize = bufferSize;</span>
<span class="nc" id="L243">            return this;</span>
        }

        public BigFileReader build() {
<span class="nc" id="L247">            return new BigFileReader(this.file, this.handle, this.charset, this.bufferSize, this.threadSize);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>